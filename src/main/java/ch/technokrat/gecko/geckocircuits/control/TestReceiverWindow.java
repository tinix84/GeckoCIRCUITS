/*  This file is part of GeckoCIRCUITS. Copyright (C) ETH Zurich, Gecko-Simulations GmbH
 *
 *  GeckoCIRCUITS is free software: you can redistribute it and/or modify it under 
 *  the terms of the GNU General Public License as published by the Free Software 
 *  Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *  GeckoCIRCUITS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 *  PURPOSE.  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 *  GeckoCIRCUITS.  If not, see <http://www.gnu.org/licenses/>.
 */
package ch.technokrat.gecko.geckocircuits.control;

import ch.technokrat.gecko.geckocircuits.allg.SaveViewFrame;
import ch.technokrat.gecko.geckocircuits.allg.StartupWindow;
import ch.technokrat.gecko.geckocircuits.allg.TechFormat;
import ch.technokrat.gecko.geckocircuits.circuit.TokenMap;
import ch.technokrat.gecko.geckocircuits.datacontainer.ContainerStatus;
import ch.technokrat.gecko.geckocircuits.datacontainer.DataContainerFourier;
import ch.technokrat.gecko.geckocircuits.datacontainer.DataContainerCompressable;
import ch.technokrat.gecko.geckocircuits.datacontainer.DataContainerSimple;
import ch.technokrat.gecko.geckocircuits.newscope.AbstractScopeSignal;
import ch.technokrat.gecko.geckocircuits.newscope.DialogConnectSignalsGraphs;
import ch.technokrat.gecko.geckocircuits.newscope.GraferV4;
import ch.technokrat.gecko.geckocircuits.newscope.MemoryContainer;
import ch.technokrat.gecko.geckocircuits.newscope.NewScope;
import ch.technokrat.gecko.geckocircuits.newscope.ScopeSettings;
import ch.technokrat.gecko.geckocircuits.newscope.TimeSeriesConstantDt;
import ch.technokrat.gecko.geckocircuits.control.QuasiPeakCalculator;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import javax.swing.JFrame;
import javax.swing.JOptionPane;

public final class TestReceiverWindow extends JFrame {

    private static final TechFormat tcf = new TechFormat();
    private final ReglerCISPR16 _reglerCISPR16;
    private final Cispr16Settings _settings;
    private boolean initDone = false;
    private final GraferV4 _graferNew;
    private final NewScope _graferPanel;
    private TestReceiverCalculation _calculatorNew;
    private int _calculationDoneForHash;
    private CalculationRunnable _calculationRunnable;
    private DataContainerCompressable _dataContainer;
    private static final int NUMBER_SIGNALS = 8;
    private static final String[] SIGNAL_NAMES =
            new String[]{"Class A", "Class B", "Maximum est.", "Peak", "Quasi-Peak", "Average", "Minimum est.", "Fourier"};
    private CisprDataExport _dataDialog;
    public static final int INDEX_CLASS_A = 0;
    public static final int INDEX_CLASS_B = 1;
    public static final int INDEX_MAX_EST = 2;
    public static final int INDEX_PEAK = 3;
    public static final int INDEX_QUASI_PEAK = 4;
    public static final int INDEX_AVERAGE = 5;
    public static final int INDEX_MINIMUM_EST = 6;
    public static final int INDEX_FOURIER = 7;
    private boolean _calculationCompleted = false;

    public TestReceiverWindow(final ReglerCISPR16 regelBlock) {
        initComponents();
        _reglerCISPR16 = regelBlock;
        _settings = regelBlock.getSettings();

        Dimension windowSize = new Dimension(800, 600);
        setPreferredSize(windowSize);
        setSize(windowSize);

        _graferNew = new GraferV4(new ScopeSettings());
        _graferNew.setNewXNames("f [Hz] = ", "t [sec] = ");
        _graferNew.setSimulationTimeBoundaries(10, 100000);
        _graferPanel = new NewScope(_graferNew);
        _graferPanel.setTabsInvisible();        
        jPanelPlot.add(_graferPanel);        

        if (_reglerCISPR16._zvDatenRam == null) {
            jButtonCalculate.setEnabled(false);
            jLabelStatus.setText("No simulation data available.");
        }
        
        _graferNew.createInitialDiagramCISPR16(true, false, NUMBER_SIGNALS);        
        _graferNew.setSymbolsInCurveEnabled(new int[]{3, 4, 5});
        _graferNew._manager.getDiagrams().get(0).setAllCurvesWithBars(new int[]{3, 4, 5});
        _graferNew.setSimulationTimeBoundaries(9000, 3e6);
        createEmptyData();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        buttonGroup3 = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanelCalculationSettings = new javax.swing.JPanel();
        jButtonCalculate = new javax.swing.JButton();
        jButtonAbort = new javax.swing.JButton();
        jButtonCancel = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jCheckBoxPeak = new javax.swing.JCheckBox();
        jCheckBoxQuasiPeak = new javax.swing.JCheckBox();
        jCheckBoxAverage = new javax.swing.JCheckBox();
        jRadioButtonRMS = new javax.swing.JRadioButton();
        jRadioButtonAmpl = new javax.swing.JRadioButton();
        jCheckBoxBlackman = new javax.swing.JCheckBox();
        jLabel4 = new javax.swing.JLabel();
        jPanelQPFiltering = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jSpinnerMinFreq = new javax.swing.JSpinner();
        jSpinnerMaximum = new javax.swing.JSpinner();
        jRadioButtonInterval = new javax.swing.JRadioButton();
        jRadioButtonAuto = new javax.swing.JRadioButton();
        jSpinnerIntervalFreq = new javax.swing.JSpinner();
        jSpinnerThreshold = new javax.swing.JSpinner();
        jPanelStatus = new javax.swing.JPanel();
        jLabelStatus = new javax.swing.JLabel();
        jPanelPlot = new javax.swing.JPanel();
        jPanelData = new javax.swing.JPanel();
        dataContainerTable1 = new ch.technokrat.gecko.geckocircuits.datacontainer.DataContainerTable();
        jPanelInfo = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jToolBar1 = new javax.swing.JToolBar();
        jButtonSave = new javax.swing.JButton();
        jButtonImage = new javax.swing.JButton();
        jButtonPlotOptions = new javax.swing.JButton();
        jButtonPlotOptions1 = new javax.swing.JButton();

        setLocationByPlatform(true);
        setMinimumSize(new java.awt.Dimension(650, 600));
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

        jTabbedPane1.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N

        jButtonCalculate.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jButtonCalculate.setText("Calculate");
        jButtonCalculate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCalculateActionPerformed(evt);
            }
        });

        jButtonAbort.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jButtonAbort.setText("Abort calculation");
        jButtonAbort.setEnabled(false);
        jButtonAbort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAbortActionPerformed(evt);
            }
        });

        jButtonCancel.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jButtonCancel.setText("Close window");
        jButtonCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCancelActionPerformed(evt);
            }
        });

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Algorithms and Plotting", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Arial", 0, 12))); // NOI18N

        jCheckBoxPeak.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jCheckBoxPeak.setText("Calculate Peak detection");
        jCheckBoxPeak.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxPeakActionPerformed(evt);
            }
        });

        jCheckBoxQuasiPeak.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jCheckBoxQuasiPeak.setSelected(true);
        jCheckBoxQuasiPeak.setText("Calculate Quasi-Peak detection");
        jCheckBoxQuasiPeak.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxQuasiPeakActionPerformed(evt);
            }
        });

        jCheckBoxAverage.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jCheckBoxAverage.setText("Calculate Average detection");
        jCheckBoxAverage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxAverageActionPerformed(evt);
            }
        });

        buttonGroup2.add(jRadioButtonRMS);
        jRadioButtonRMS.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jRadioButtonRMS.setSelected(true);
        jRadioButtonRMS.setText("RMS display of FFT");
        jRadioButtonRMS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonRMSActionPerformed(evt);
            }
        });

        buttonGroup2.add(jRadioButtonAmpl);
        jRadioButtonAmpl.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jRadioButtonAmpl.setText("Amplitude display of FFT");
        jRadioButtonAmpl.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonAmplActionPerformed(evt);
            }
        });

        jCheckBoxBlackman.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jCheckBoxBlackman.setSelected(true);
        jCheckBoxBlackman.setText("use Blackman filtering (lowers noise floor)");
        jCheckBoxBlackman.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxBlackmanActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jLabel4.setText("Please note: Peak, Quasi-Peak and Average signals are always displayed as RMS values.");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(54, 54, 54)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxPeak)
                    .addComponent(jCheckBoxQuasiPeak)
                    .addComponent(jCheckBoxAverage))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jCheckBoxBlackman)
                .addGap(49, 49, 49))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGap(45, 45, 45)
                        .addComponent(jRadioButtonRMS)
                        .addGap(18, 18, 18)
                        .addComponent(jRadioButtonAmpl)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, 595, Short.MAX_VALUE)
                        .addContainerGap())))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxPeak)
                    .addComponent(jCheckBoxBlackman))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxQuasiPeak)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxAverage)
                .addGap(18, 18, 18)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButtonRMS)
                    .addComponent(jRadioButtonAmpl))
                .addGap(305, 305, 305))
        );

        jPanelQPFiltering.setBorder(javax.swing.BorderFactory.createTitledBorder("Quasi-Peak, Peak and Avg frequency filtering - frequency range and interval"));

        jLabel1.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jLabel1.setText("f_max [Hz]");

        jLabel2.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jLabel2.setText("f_min [Hz]");

        jSpinnerMinFreq.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jSpinnerMinFreq.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(9000.0d), Double.valueOf(1.0d), null, Double.valueOf(1000.0d)));
        jSpinnerMinFreq.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSpinnerMinFreqStateChanged(evt);
            }
        });

        jSpinnerMaximum.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jSpinnerMaximum.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(2000000.0d), Double.valueOf(100.0d), null, Double.valueOf(100000.0d)));
        jSpinnerMaximum.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSpinnerMaximumStateChanged(evt);
            }
        });

        buttonGroup3.add(jRadioButtonInterval);
        jRadioButtonInterval.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jRadioButtonInterval.setText("Frequency interval [Hz]:");
        jRadioButtonInterval.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonIntervalActionPerformed(evt);
            }
        });

        buttonGroup3.add(jRadioButtonAuto);
        jRadioButtonAuto.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jRadioButtonAuto.setSelected(true);
        jRadioButtonAuto.setText("Automatic frequency evalulation - filtering strength [0...1]:");
        jRadioButtonAuto.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonAutoActionPerformed(evt);
            }
        });

        jSpinnerIntervalFreq.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jSpinnerIntervalFreq.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(9000.0d), Double.valueOf(1.0d), null, Double.valueOf(1000.0d)));
        jSpinnerIntervalFreq.setEnabled(false);
        jSpinnerIntervalFreq.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSpinnerIntervalFreqStateChanged(evt);
            }
        });

        jSpinnerThreshold.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jSpinnerThreshold.setModel(new javax.swing.SpinnerNumberModel(0.5d, 0.0d, 1.0d, 0.1d));
        jSpinnerThreshold.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSpinnerThresholdStateChanged(evt);
            }
        });

        javax.swing.GroupLayout jPanelQPFilteringLayout = new javax.swing.GroupLayout(jPanelQPFiltering);
        jPanelQPFiltering.setLayout(jPanelQPFilteringLayout);
        jPanelQPFilteringLayout.setHorizontalGroup(
            jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelQPFilteringLayout.createSequentialGroup()
                .addGap(57, 57, 57)
                .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanelQPFilteringLayout.createSequentialGroup()
                        .addComponent(jRadioButtonAuto)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSpinnerThreshold, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanelQPFilteringLayout.createSequentialGroup()
                        .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelQPFilteringLayout.createSequentialGroup()
                                .addComponent(jRadioButtonInterval)
                                .addGap(41, 41, 41)
                                .addComponent(jSpinnerIntervalFreq, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelQPFilteringLayout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jSpinnerMinFreq, javax.swing.GroupLayout.PREFERRED_SIZE, 117, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel1)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSpinnerMaximum, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanelQPFilteringLayout.setVerticalGroup(
            jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelQPFilteringLayout.createSequentialGroup()
                .addGap(7, 7, 7)
                .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jSpinnerMaximum, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel1))
                    .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jSpinnerMinFreq, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel2)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButtonInterval)
                    .addComponent(jSpinnerIntervalFreq, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelQPFilteringLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jRadioButtonAuto)
                    .addComponent(jSpinnerThreshold, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanelStatus.setBorder(javax.swing.BorderFactory.createTitledBorder("Status"));

        jLabelStatus.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jLabelStatus.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelStatus.setText("...");

        javax.swing.GroupLayout jPanelStatusLayout = new javax.swing.GroupLayout(jPanelStatus);
        jPanelStatus.setLayout(jPanelStatusLayout);
        jPanelStatusLayout.setHorizontalGroup(
            jPanelStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelStatusLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabelStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanelStatusLayout.setVerticalGroup(
            jPanelStatusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelStatusLayout.createSequentialGroup()
                .addComponent(jLabelStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout jPanelCalculationSettingsLayout = new javax.swing.GroupLayout(jPanelCalculationSettings);
        jPanelCalculationSettings.setLayout(jPanelCalculationSettingsLayout);
        jPanelCalculationSettingsLayout.setHorizontalGroup(
            jPanelCalculationSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCalculationSettingsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCalculationSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jPanelQPFiltering, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelCalculationSettingsLayout.createSequentialGroup()
                        .addGap(107, 107, 107)
                        .addComponent(jButtonCalculate, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonAbort, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonCancel, javax.swing.GroupLayout.PREFERRED_SIZE, 125, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelStatus, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(72, Short.MAX_VALUE))
        );

        jPanelCalculationSettingsLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jButtonCalculate, jButtonCancel});

        jPanelCalculationSettingsLayout.setVerticalGroup(
            jPanelCalculationSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCalculationSettingsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 202, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelQPFiltering, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jPanelCalculationSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonAbort)
                    .addComponent(jButtonCalculate)
                    .addComponent(jButtonCancel))
                .addContainerGap())
        );

        jTabbedPane1.addTab("Calculation", jPanelCalculationSettings);

        jPanelPlot.setLayout(new java.awt.BorderLayout());
        jTabbedPane1.addTab("Plot", jPanelPlot);

        javax.swing.GroupLayout jPanelDataLayout = new javax.swing.GroupLayout(jPanelData);
        jPanelData.setLayout(jPanelDataLayout);
        jPanelDataLayout.setHorizontalGroup(
            jPanelDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(dataContainerTable1, javax.swing.GroupLayout.DEFAULT_SIZE, 715, Short.MAX_VALUE)
        );
        jPanelDataLayout.setVerticalGroup(
            jPanelDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(dataContainerTable1, javax.swing.GroupLayout.DEFAULT_SIZE, 483, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab("Data", jPanelData);

        jTextArea1.setColumns(20);
        jTextArea1.setEditable(false);
        jTextArea1.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jTextArea1.setRows(5);
        jTextArea1.setText("The EMI control block uses timedomain simulation data to calculate conducted noise\nemissions in the frequency domain - similar to a hardware test receiver. Please note,\nthat we cannot guarantee that the actual noise levels in your hardware are below the\nsimulated results, since your hardware results depend on many parameters like \nparasitics, switch performance, .... Therefore, this block should be seen as design \ntool for your EMI-filter design - however without any guarantee of absolute accuracy.\n\nSimilar to a real test-receiver, you can select between different signal processing options,\nas e.g. quasi-peak detection or peak detection. The minimum/maximum estimation gives\na quick solution of the emi noise range.\n\nWhen the simulation data requires an improvement of the dynamic range of the\ntest-receiver, we recommend to turn on the \"Blackman filtering\". This is especially\nrequired when you include an EMI filter into your simulation, since the EMI filter\nactually removes the noise spectrum that you wish do display in the plots.\nWithout Blackman-Filter, the Fourier data is actually a pure Fourier-transform\nof your input waveforms, and the detector postprocessing will be performed\non this data.");
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout jPanelInfoLayout = new javax.swing.GroupLayout(jPanelInfo);
        jPanelInfo.setLayout(jPanelInfoLayout);
        jPanelInfoLayout.setHorizontalGroup(
            jPanelInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelInfoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 691, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanelInfoLayout.setVerticalGroup(
            jPanelInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelInfoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 459, Short.MAX_VALUE)
                .addContainerGap())
        );

        jTabbedPane1.addTab("Information", jPanelInfo);

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jButtonSave.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jButtonSave.setText("Save data");
        jButtonSave.setEnabled(false);
        jButtonSave.setFocusable(false);
        jButtonSave.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonSave.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSaveActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonSave);

        jButtonImage.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jButtonImage.setText("Save as image");
        jButtonImage.setEnabled(false);
        jButtonImage.setFocusable(false);
        jButtonImage.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonImage.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonImageActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonImage);

        jButtonPlotOptions.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jButtonPlotOptions.setText("Plot options");
        jButtonPlotOptions.setFocusable(false);
        jButtonPlotOptions.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonPlotOptions.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonPlotOptions.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPlotOptionsActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonPlotOptions);

        jButtonPlotOptions1.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        jButtonPlotOptions1.setText("Component settings");
        jButtonPlotOptions1.setFocusable(false);
        jButtonPlotOptions1.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonPlotOptions1.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonPlotOptions1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPlotOptions1ActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonPlotOptions1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTabbedPane1))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//NOPMD//GEN-FIRST:event_formComponentResized
    }//GEN-LAST:event_formComponentResized

    private List<Integer> eliminateWithSlope(final double baseFreq, float[] maximumCalculation, List<Integer> filtered) {
        final double userFilterStrength = ((Double) jSpinnerThreshold.getValue());

        if (userFilterStrength < 1e-3) {
            return filtered;
        }

        final double SLOPE = 3 - 2 * userFilterStrength;

        Set<Integer> removeCandidates = new LinkedHashSet<Integer>();

        for (int i = 0; i < filtered.size(); i++) {
            int lookAtIndex = filtered.get(i);
            double lookAtFrequency = lookAtIndex * baseFreq;
            float peakValue = maximumCalculation[lookAtIndex];
            for (int j = 0; j < i; j++) {
                int compareIndex = filtered.get(j);
                double compareFreq = baseFreq * compareIndex;
                float compareValue = maximumCalculation[compareIndex];

                if (compareFreq < (0.9 - userFilterStrength / 4) * lookAtFrequency) {
                    continue;
                }

                double a = peakValue / Math.pow(lookAtFrequency, SLOPE);
                double threshold = a * Math.pow(compareFreq, SLOPE);
                if (compareValue < threshold) {
                    removeCandidates.add(compareIndex);
                }
            }


            for (int j = i + 1; j < filtered.size(); j++) {
                int compareIndex = filtered.get(j);
                double compareFreq = baseFreq * compareIndex;
                float compareValue = maximumCalculation[compareIndex];
                double frequencyDiff = baseFreq * (compareFreq - lookAtFrequency);

                if (frequencyDiff > (1.1 + userFilterStrength) * lookAtFrequency) {
                    continue;
                }

                double a = peakValue * Math.pow(lookAtFrequency, SLOPE);
                double threshold = a / Math.pow(compareFreq, SLOPE);

                if (compareValue < threshold) {
                    removeCandidates.add(compareIndex);
                }

            }

        }

        List<Integer> returnValue = new ArrayList<Integer>();
        for (Integer index : filtered) {
            if (!removeCandidates.contains(index)) {
                returnValue.add(index);
            }
        }

        return returnValue;
    }

    private List<Integer> eliminateMaxMinMax(float[] maximumCalculation, List<Integer> filtered) {
        List<Integer> returnValue = new ArrayList<Integer>();
        returnValue.add(filtered.get(0));

        for (int i = 1; i < filtered.size() - 1; i++) {
            int prevIndex = filtered.get(i - 1);
            int index = filtered.get(i);
            int nextIndex = filtered.get(i + 1);

            float prevValue = maximumCalculation[prevIndex];
            float indexValue = maximumCalculation[index];
            float nextIndexValue = maximumCalculation[nextIndex];

            if (!(indexValue <= prevValue && nextIndexValue >= indexValue)) {
                returnValue.add(index);
            }
        }
        return returnValue;
    }

    private double relativeMeasure(float value1, float value2) {
        return Math.abs((value1 - value2) / (1e-10 + value1 + value2));
    }

    private List<Integer> eliminateDataPointsTooClose200Hz(TestReceiverCalculation calculator, float[] maximumCalculation, List<Integer> originalList) {

        final List<Integer> returnValue = new ArrayList<Integer>();
        final int NN = calculator._fftOrig._resampledN / 2;
        double baseFreq = calculator._fftOrig.baseFrequency;
        for (int i = 0; i < originalList.size(); i++) {
            int indexCandidate = originalList.get(i);

            int maxIndexIn200HzRange = indexCandidate + (int) (200 / baseFreq);
            maxIndexIn200HzRange = Math.min(NN, maxIndexIn200HzRange);


            List<Integer> compareIndices = findExistingIndicesInRange(indexCandidate, i, maxIndexIn200HzRange, originalList);
            if (compareIndices.size() == 1) {
                returnValue.add(indexCandidate);
            } else {
                int indexWithLocalMaximum = findIndexWithMaximum(maximumCalculation, compareIndices);
                int lastCompareIndex = compareIndices.get(compareIndices.size() - 1);
                returnValue.add(indexWithLocalMaximum);
                int nextValueOf_i = i;
                while (nextValueOf_i + 1 < originalList.size() && originalList.get(nextValueOf_i) < lastCompareIndex) {
                    nextValueOf_i++;
                }
                i = nextValueOf_i;
            }
            returnValue.add(originalList.get(i));
        }
        return returnValue;
    }

    private List<Integer> eliminateBelowMedian200Hz(TestReceiverCalculation calculator, float[] maximumCalculation, List<Integer> originalList) {

        double medianSum = 0;
        int counter = 0;
        for (Integer index : originalList) {
            double freq = calculator._fftOrig.baseFrequency * index;
            if (freq > 150000) {
                break;
            }
            medianSum += maximumCalculation[index];
            counter++;
        }

        medianSum = medianSum / originalList.size() / 2.0;
        final List<Integer> returnValue = new ArrayList<Integer>();

        for (int i = 0; i < originalList.size(); i++) {
            int indexCandidate = originalList.get(i);
            float value = maximumCalculation[indexCandidate];

            if (value > medianSum) {
                returnValue.add(indexCandidate);
            }
        }
        return returnValue;
    }

    private List<Integer> eliminateDataPointsTooClose9kHz(TestReceiverCalculation calculator, float[] maximumCalculation, List<Integer> originalList) {

        final List<Integer> returnValue = new ArrayList<Integer>();
        final int NN = calculator._fftOrig._resampledN / 2;
        double baseFreq = calculator._fftOrig.baseFrequency;
        for (int i = 0; i < originalList.size(); i++) {
            int indexCandidate = originalList.get(i);
            double indexFrequency = baseFreq * indexCandidate;
            if (indexFrequency < 150000) {
                returnValue.add(indexCandidate);
                continue;
            }

            int maxIndexIn9kHzRange = indexCandidate + (int) (8000 / baseFreq);
            maxIndexIn9kHzRange = Math.min(NN, maxIndexIn9kHzRange);


            List<Integer> compareIndices = findExistingIndicesInRange(indexCandidate, i, maxIndexIn9kHzRange, originalList);

            if (compareIndices.size() == 1) {
                returnValue.add(indexCandidate);
            } else {
                int indexWithLocalMaximum = findIndexWithMaximum(maximumCalculation, compareIndices);
                int lastCompareIndex = compareIndices.get(compareIndices.size() - 1);
                returnValue.add(indexWithLocalMaximum);
                int nextValueOf_i = i;
                while (nextValueOf_i + 1 < originalList.size() && originalList.get(nextValueOf_i) < lastCompareIndex) {
                    nextValueOf_i++;
                }

                i = nextValueOf_i;
            }
            //returnValue.add(originalList.get(i));
        }

        return returnValue;
    }

    private int findIndexWithMaximum(float[] maximumCalculation, List<Integer> compareIndices) {
        int maxIndex = -1;
        float maxValue = -1e10f;

        for (Integer index : compareIndices) {
            if (maximumCalculation[index] >= maxValue) {
                maxValue = maximumCalculation[index];
                maxIndex = index;
            }
        }
        return maxIndex;
    }

    private List<Integer> findExistingIndicesInRange(int startRange, int indexOfStartRange, int stopRange, List<Integer> originalList) {
        List<Integer> returnValue = new ArrayList<Integer>();
        for (int i = indexOfStartRange; i < originalList.size(); i++) {
            int lookAtIndex = originalList.get(i);
            if (lookAtIndex > stopRange) {
                break;
            }
            returnValue.add(lookAtIndex);
        }
        return returnValue;
    }

    void exportAscii(final StringBuffer ascii) {
        _graferPanel.exportInvidualControl(ascii);
        _graferNew.exportIndividualCONTROL(ascii);
    }

    void createEmptyData() {
        DataContainerSimple dcs1 = DataContainerSimple.fabricConstantDtTimeSeries(8, 1000);
        addSignalNames();
        for (int i = 0; i < NUMBER_SIGNALS; i++) {
            dcs1.setSignalName(SIGNAL_NAMES[i], i);
        }

        for (float freq = 150000; freq < 1000000; freq += 50000) {
            float[] values = new float[]{getClassAValue(freq), getClassBValue(freq), Float.NaN, Float.NaN, Float.NaN, Float.NaN, Float.NaN, Float.NaN};
            dcs1.insertValuesAtEnd(values, freq);
        }

        dcs1.setContainerStatus(ContainerStatus.PAUSED);
        _graferNew.setDataContainer(dcs1);
    }

    void importAscii(final TokenMap tokenMap) {
        _graferNew.importIndividualCONTROL(tokenMap);
        if(_graferNew._manager.getDiagrams().size() == 0) {
            _graferNew.createInitialDiagramCISPR16(true, false, NUMBER_SIGNALS);        
        }
        _graferPanel.importIndividualCONTROL(tokenMap);
        createEmptyData();
    }

    private Set<Integer> findMaximumPeaks(final TestReceiverCalculation calculator,
            final float[] maximumCalculation, float[] minimumCalculation) {
        final List<Integer> returnValue = new ArrayList<Integer>();

        double baseFreq = calculator._fftOrig.baseFrequency;

        for (int i = 1; i < calculator._fftOrig._resampledN / 2 - 1; i++) {
            double frequency = i * baseFreq;
            if (frequency < (Double) jSpinnerMinFreq.getValue() || frequency > (Double) jSpinnerMaximum.getValue()) {
                continue;
            }
            if (maximumCalculation[i - 1] <= maximumCalculation[i] && maximumCalculation[i] >= maximumCalculation[i + 1]) {
                returnValue.add(i);
            }
        }

        List<Integer> filtered = eliminateDataPointsTooClose200Hz(calculator, maximumCalculation, returnValue);
        //List<Integer> filtered = eliminateBelowMedian200Hz(calculator, maximumCalculation, returnValue);
        filtered = eliminateDataPointsTooClose9kHz(calculator, maximumCalculation, filtered);

        for (int i = 0; i < 10; i++) {
            int sizeBefore = filtered.size();
            filtered = eliminateMaxMinMax(maximumCalculation, filtered);
            int sizeAfter = filtered.size();
            if (sizeAfter - sizeBefore <= 1) {
                break;
            }
        }
        filtered = eliminateWithSlope(calculator._fftOrig.baseFrequency, maximumCalculation, filtered);
        return new LinkedHashSet<Integer>(filtered);
    }

    void saveFourierDataToFile(final File file) {
        checkCalculationAvailable();
        CisprDataExport.saveData(INDEX_FOURIER, _dataContainer, file, true);
    }

    void savePeakDataToFile(File file) {
        checkCalculationAvailable();
        CisprDataExport.saveData(INDEX_PEAK, _dataContainer, file, true);
    }

    void saveQuasiPeakDataToFile(File file) {
        checkCalculationAvailable();
        CisprDataExport.saveData(INDEX_QUASI_PEAK, _dataContainer, file, true);
    }

    void saveAverageDataToFile(File file) {
        checkCalculationAvailable();
        CisprDataExport.saveData(INDEX_AVERAGE, _dataContainer, file, true);
    }

    private void checkCalculationAvailable() {
        if (!_calculationCompleted) {
            throw new RuntimeException("No simulation data available. Please start calculation before saving data.");
        }
    }

    class CalculationRunnable implements Runnable {

        public boolean _abortCalculation = false;
        private MemoryContainer _memoryContainer;

        @Override
        public void run() {

            if (_calculatorNew == null || _calculationDoneForHash != getHashCodeForCalculator()) {
                _calculatorNew = new TestReceiverCalculation(_reglerCISPR16._zvDatenRam, _settings);
                _calculationDoneForHash = getHashCodeForCalculator();
            }
            
            TimeSeriesConstantDt timeSeries = new TimeSeriesConstantDt();
            
            
            _dataContainer = new DataContainerCompressable(NUMBER_SIGNALS, timeSeries,
                    SIGNAL_NAMES, "f");

            float[] min = new float[_calculatorNew._fftOrig._resampledN / 2];
            float[] max = new float[_calculatorNew._fftOrig._resampledN / 2];

            QuasiPeakCalculator.calculateMinMaxEstimation(min, max, _settings._useBlackman.getValue(), _calculatorNew._fftOrig);
            jLabelStatus.setText("Initial FFT completed.");
            jButtonAbort.setEnabled(true);
            Set<Integer> peaks = Collections.EMPTY_SET;

            if (jRadioButtonInterval.isSelected()) {
                peaks = getIndicesInInterval(_calculatorNew);
            } else {
                peaks = findMaximumPeaks(_calculatorNew, max, min);
            }

            double baseFreq = _calculatorNew._fftOrig.baseFrequency;


            for (int i = 1; i < _calculatorNew._fftOrig._resampledN / 2; i++) {
                double frequency = i * baseFreq;                
                if (_abortCalculation) {
                    return;
                }

                float magnitude = _calculatorNew._fftOrig._magnitudes[i];
                float[] data = _dataContainer.getMemoryContainer().getArrayInitializedWithNaN();

                data[INDEX_CLASS_A] = getClassAValue(frequency);
                data[INDEX_CLASS_B] = getClassBValue(frequency);
                data[INDEX_MAX_EST] = calculateDbMu(max[i]);
                data[INDEX_MINIMUM_EST] = calculateDbMu(min[i]);
                if (_settings._showRMSValues.getValue()) {
                    data[7] = calculateDbMu(magnitude);
                } else {
                    data[7] = calculateDbMu(Math.sqrt(2) * magnitude);
                }


                double lowerLimit = ((Double) jSpinnerMinFreq.getValue());
                double upperLimit = (Double) jSpinnerMaximum.getValue();

                double roundedLowerLimit = ((long) (lowerLimit / baseFreq)) * baseFreq;
                double roundedUpperLimit = ((long) (upperLimit / baseFreq)) * baseFreq;


                if (peaks.contains(i)) {
                    try {
                        if (roundedLowerLimit <= frequency && frequency <= roundedUpperLimit) {
                            jLabelStatus.setText("Calculating signal at frequency" + " " + tcf.formatENG(frequency, 1) + " Hz");
                            double[] calcData = _calculatorNew.calculateAtFrequency(frequency);

                            if (_settings._peak.getValue()) {
                                data[INDEX_PEAK] = calculateDbMu(calcData[0]);
                            }

                            if (_settings._qpeak.getValue()) {
                                data[INDEX_QUASI_PEAK] = calculateDbMu(calcData[1]);
                            }

                            if (_settings._average.getValue()) {
                                data[INDEX_AVERAGE] = calculateDbMu(calcData[2]);
                            }
                        }
                    } catch (OutOfMemoryError err) {                        
                        JOptionPane.showMessageDialog(null,
                                "Error: Java is out of memory. Please increase JVM memory.\nAborting calculation.\n" + 
                                err.toString(),
                                "Memory error!",
                                JOptionPane.ERROR_MESSAGE);
                        _abortCalculation = true;                        
                        abortCalculation();
                        err.printStackTrace();
                    } catch (Throwable error) {
                        System.err.println("error: " + error.getMessage());
                        error.printStackTrace();
                    }
                }
                _dataContainer.insertValuesAtEnd(data, frequency);
            }


            dataContainerTable1.setDataContainer(_dataContainer);

            addSignalNames();

            _dataContainer.setContainerStatus(ContainerStatus.PAUSED);
            _graferNew.setDataContainer(_dataContainer);

            setCalculationCompleted();
        }

        private Set<Integer> getIndicesInInterval(TestReceiverCalculation calculator) {
            Set<Integer> returnValue = new LinkedHashSet<Integer>();
            double baseFreq = calculator._fftOrig.baseFrequency;

            double minimumFreq = (Double) jSpinnerMinFreq.getValue();
            double maximumFreq = (Double) jSpinnerMaximum.getValue();

            int startIndex = (int) (minimumFreq / baseFreq);
            int stopIndex = (int) (maximumFreq / baseFreq);
            int intervalLength = (int) ((Double) jSpinnerIntervalFreq.getValue() / baseFreq);

            for (int i = startIndex; i <= stopIndex; i += intervalLength) {
                returnValue.add(i);
            }

            return returnValue;
        }

        private int getHashCodeForCalculator() {
            int returnValue = _reglerCISPR16._zvDatenRam.hashCode();
            if (_settings._useBlackman.getValue()) {
                returnValue += 1;
            }
            return returnValue;
        }
    }

    private void setCalculationCompleted() {
        jLabelStatus.setText("Calculation completed.");
        jButtonCalculate.setEnabled(true);
        jButtonAbort.setEnabled(false);
        jButtonCancel.setEnabled(true);
        jButtonSave.setEnabled(true);
        jButtonImage.setEnabled(true);
        _calculationCompleted = true;
        _calculationRunnable = null;
    }

    private void addSignalNames() {
        final Stack<AbstractScopeSignal> inputSignals = new Stack<AbstractScopeSignal>();
        for (int i = 0; i < NUMBER_SIGNALS; i++) {
            inputSignals.add(new ScopeSignalSimpleName(SIGNAL_NAMES[i]));
        }
        _graferNew._manager.setInputSignals(inputSignals);
    }

    private static float calculateDbMu(final double value) {
        if (value > 0) {
            return (float) (20 * Math.log10(value / 1e-6));
        } else {
            return Float.NaN;
        }
    }

    private void jButtonCalculateActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jButtonCalculateActionPerformed
        /*
        if(StartupWindow.testDialogOpenSourceVersion("EMI Testreceiver")) {            
            return;                        
        }*/
        
        startCalculation(true);
    }//GEN-LAST:event_jButtonCalculateActionPerformed

    public void startCalculation(boolean useNewThread) {
        jLabelStatus.setText("Starting testreceiver calculation (FFT).");
        jButtonCalculate.setEnabled(false);
        jButtonAbort.setEnabled(true);
        _calculationRunnable = new CalculationRunnable();
        Thread runThread = new Thread(_calculationRunnable);
        if (useNewThread) {
            runThread.start();
        } else {
            runThread.run();
        }        

    }

    public void abortCalculation() {
        jButtonCalculate.setEnabled(true);
        jButtonAbort.setEnabled(false);
                
        if (_calculationRunnable != null) {
            _calculationRunnable._abortCalculation = true;        
            _calculationRunnable = null;
        }
    }

    private void jButtonAbortActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jButtonAbortActionPerformed
        abortCalculation();
    }//GEN-LAST:event_jButtonAbortActionPerformed

    private void jButtonCancelActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jButtonCancelActionPerformed
        updateSettings();
        this.dispose();
    }//GEN-LAST:event_jButtonCancelActionPerformed

    private void jSpinnerMinFreqStateChanged(javax.swing.event.ChangeEvent evt) {//NOPMD//GEN-FIRST:event_jSpinnerMinFreqStateChanged
        updateSettings();
    }//GEN-LAST:event_jSpinnerMinFreqStateChanged

    private void jCheckBoxPeakActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jCheckBoxPeakActionPerformed
        updateSettings();
    }//GEN-LAST:event_jCheckBoxPeakActionPerformed

    private void jCheckBoxQuasiPeakActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jCheckBoxQuasiPeakActionPerformed
        updateSettings();
    }//GEN-LAST:event_jCheckBoxQuasiPeakActionPerformed

    private void jCheckBoxAverageActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jCheckBoxAverageActionPerformed
        updateSettings();
    }//GEN-LAST:event_jCheckBoxAverageActionPerformed

    private void jSpinnerMaximumStateChanged(javax.swing.event.ChangeEvent evt) {//NOPMD//GEN-FIRST:event_jSpinnerMaximumStateChanged
        updateSettings();
    }//GEN-LAST:event_jSpinnerMaximumStateChanged

    private void jCheckBoxBlackmanActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jCheckBoxBlackmanActionPerformed
        updateSettings();
    }//GEN-LAST:event_jCheckBoxBlackmanActionPerformed

    private void jRadioButtonAmplActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jRadioButtonAmplActionPerformed
        updateSettings();
    }//GEN-LAST:event_jRadioButtonAmplActionPerformed

    private void jRadioButtonRMSActionPerformed(java.awt.event.ActionEvent evt) {//NOPMD//GEN-FIRST:event_jRadioButtonRMSActionPerformed
        updateSettings();
    }//GEN-LAST:event_jRadioButtonRMSActionPerformed

    private void jButtonPlotOptionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPlotOptionsActionPerformed
        
        DialogConnectSignalsGraphs dialog = new DialogConnectSignalsGraphs(_graferNew);
        dialog.setVisible(true);
    }//GEN-LAST:event_jButtonPlotOptionsActionPerformed

    private void jRadioButtonIntervalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonIntervalActionPerformed

        jSpinnerIntervalFreq.setEnabled(jRadioButtonInterval.isSelected());
    }//GEN-LAST:event_jRadioButtonIntervalActionPerformed

    private void jRadioButtonAutoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonAutoActionPerformed
        jSpinnerIntervalFreq.setEnabled(jRadioButtonInterval.isSelected());
        jSpinnerThreshold.setEnabled(jRadioButtonAuto.isSelected());
    }//GEN-LAST:event_jRadioButtonAutoActionPerformed

    private void jButtonImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonImageActionPerformed
        new SaveViewFrame(this, _graferNew).setVisible(true);
    }//GEN-LAST:event_jButtonImageActionPerformed

    private void jButtonSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSaveActionPerformed
        if (_dataDialog == null) {
            _dataDialog = new CisprDataExport(this, _settings, _dataContainer);
        }
        _dataDialog.setVisible(true);

    }//GEN-LAST:event_jButtonSaveActionPerformed

    private void jSpinnerIntervalFreqStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSpinnerIntervalFreqStateChanged
        updateSettings();
    }//GEN-LAST:event_jSpinnerIntervalFreqStateChanged

    private void jSpinnerThresholdStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSpinnerThresholdStateChanged

        _settings._filterThreshold.setUserValue((Double) jSpinnerThreshold.getValue());
    }//GEN-LAST:event_jSpinnerThresholdStateChanged

    private void jButtonPlotOptions1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPlotOptions1ActionPerformed
        new CisprBlockSettings(_reglerCISPR16, this).setVisible(true);
    }//GEN-LAST:event_jButtonPlotOptions1ActionPerformed

    private void updateSettings() {
        if (_reglerCISPR16 != null && initDone) {
            _settings._peak.setUserValue(jCheckBoxPeak.isSelected());
            _settings._qpeak.setUserValue(jCheckBoxQuasiPeak.isSelected());
            _settings._average.setUserValue(jCheckBoxAverage.isSelected());
            _settings._maxFreq.setUserValue((Double) jSpinnerMaximum.getValue());
            _settings._minFreq.setUserValue((Double) jSpinnerMinFreq.getValue());
            _settings._useBlackman.setUserValue(jCheckBoxBlackman.isSelected());
            _settings._showRMSValues.setUserValue(jRadioButtonRMS.isSelected());
            _settings._automaticQPSelection.setUserValue(jRadioButtonAuto.isSelected());
            _settings._qpInteval.setUserValue((Double) jSpinnerIntervalFreq.getValue());
        }
    }

    @Override
    public void setVisible(final boolean value) {
        super.setVisible(value);

        if (value && _reglerCISPR16 != null) {
            this.setTitle(" " + _reglerCISPR16.getStringID());
            jCheckBoxPeak.setSelected(_settings._peak.getValue());
            jCheckBoxQuasiPeak.setSelected(_settings._qpeak.getValue());
            jSpinnerMaximum.setValue((Double) _settings._maxFreq.getValue());
            jSpinnerMinFreq.setValue((Double) _settings._minFreq.getValue());
            jSpinnerThreshold.setValue((Double) _settings._filterThreshold.getValue());
            jSpinnerIntervalFreq.setValue((Double) _settings._qpInteval.getValue());
            jCheckBoxAverage.setSelected(_settings._average.getValue());
            jCheckBoxBlackman.setSelected(_settings._useBlackman.getValue());
            jRadioButtonRMS.setSelected(_settings._showRMSValues.getValue());
            jRadioButtonAmpl.setSelected(!_settings._showRMSValues.getValue());
            
            if (_settings._automaticQPSelection.getValue()) {
                jRadioButtonAuto.setSelected(true);
                jSpinnerThreshold.setEnabled(true);
            } else {
                jRadioButtonInterval.setSelected(true);
                jSpinnerIntervalFreq.setEnabled(true);
                jSpinnerThreshold.setEnabled(false);
            }

            initDone = true;
        }
    }

    float getClassAValue(final double freq) {
        if (freq < 150e3) {  // f < 150kHz, Limit undefiniert 
            return Float.NaN;
        } else if (freq < 500e3) {  // 150kHz < f < 500kHz 
            return 79;
        } else if (freq < 30e6) {  // 5MHz < f < 30MHz
            return 73;
        } else {  // f > 30MHz; Limit undefiniert 
            return Float.NaN;
        }
    }

    float getClassBValue(final double freq) {

        if (freq < 150e3) {  // f < 150kHz, Limit undefiniert 
            return Float.NaN;
        } else if (freq < 500e3) {  // 150kHz < f < 500kHz 
            return (float) (66 - 10 * Math.log10(freq / 150e3) / Math.log10(500e3 / 150e3));
        } else if (freq < 5e6) {  // 500kHz < f < 5MHz
            return 56;
        } else if (freq < 30e6) {  // 5MHz < f < 30MHz
            return 60;
        } else {  // f > 30MHz; Limit undefiniert 
            return Float.NaN;
        }
    }

    public void setTestReceiverCISPR16MenueEnabled(final boolean value) {
        jButtonCalculate.setEnabled(value);
        if (value) {
            jLabelStatus.setText("Simulation finished, data available.");
        } else {
            jLabelStatus.setText("Simulation running. Waiting for data...");
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.ButtonGroup buttonGroup3;
    private ch.technokrat.gecko.geckocircuits.datacontainer.DataContainerTable dataContainerTable1;
    protected javax.swing.JButton jButtonAbort;
    protected javax.swing.JButton jButtonCalculate;
    private javax.swing.JButton jButtonCancel;
    private javax.swing.JButton jButtonImage;
    private javax.swing.JButton jButtonPlotOptions;
    private javax.swing.JButton jButtonPlotOptions1;
    private javax.swing.JButton jButtonSave;
    private javax.swing.JCheckBox jCheckBoxAverage;
    private javax.swing.JCheckBox jCheckBoxBlackman;
    private javax.swing.JCheckBox jCheckBoxPeak;
    private javax.swing.JCheckBox jCheckBoxQuasiPeak;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabelStatus;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanelCalculationSettings;
    private javax.swing.JPanel jPanelData;
    private javax.swing.JPanel jPanelInfo;
    private javax.swing.JPanel jPanelPlot;
    private javax.swing.JPanel jPanelQPFiltering;
    private javax.swing.JPanel jPanelStatus;
    private javax.swing.JRadioButton jRadioButtonAmpl;
    private javax.swing.JRadioButton jRadioButtonAuto;
    private javax.swing.JRadioButton jRadioButtonInterval;
    private javax.swing.JRadioButton jRadioButtonRMS;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSpinner jSpinnerIntervalFreq;
    private javax.swing.JSpinner jSpinnerMaximum;
    private javax.swing.JSpinner jSpinnerMinFreq;
    private javax.swing.JSpinner jSpinnerThreshold;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JToolBar jToolBar1;
    // End of variables declaration//GEN-END:variables
}
